### 动态代理可以解决什么问题呢？
可以在不修改原方法的前提下，增加方法功能，使用这节课讲得代理技术，这就是浅显的AOP。

### 基于接口的动态代理
全部源代码写在了Client.java中

         *基于接口的动态代理：
         *      涉及的类：Proxy
         *      提供者：JDK官方
         *  如何创建代理对象：
         *      使用Proxy类中的newProxyInstance方法
         *  创建代理对象的要求：
         *      被代理类最少实现一个接口，如果没有则不能使用
         * newProxyInstance方法的参数：
         *      ClassLoader:
         *          它是用于加载代理对象字节码的。和被代理对象（工厂）使用相同的的类加载器。是固定写法。
         *      Class[]: 字节码数组
         *          它是用于让代理对象和被代理对象有相同方法。
         *      InvocationHandler:用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但是不必须。
         *         此接口的实现类都是谁用谁写。
          
          

### 基于子类的动态代理（代理一个普通java类）
         *  它需要有第三方jar包的支持
         *  基于子类的动态代理：
         *      涉及的类：Proxy
         *      提供者：第三方cglib库
         *  如何创建代理对象：
         *      使用Enhancer类中的create方法
         *  创建代理对象的要求：
         *      被代理类不能是最终类（最终类值得是被final修饰的类，不可继承的类）
         *  create方法的参数：
         *      Class:字节码
         *          它是用于指定被代理对象的字节码。
         *
         *      Callback：用于提供增强的代码
         *          它是让我们写如何代理，我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         *          我们一般写的都是该接口的子接口实现类：MethodInterceptor(方法拦截)



### 总结，不管是基于接口还是基于子类，都是有固定的参数，都有如何代理（需要增强干什么事），将需要代理的放入invoke代码块里。
**动态代理的好处体现在：**
1. 连接池：
    close的方法在关闭时不是真正的关闭，而是放回池中，可以利用动态代理的方式对Connection的close方法进行增强，把它加回到池里去。
2. 解决全栈中文乱码的request对象的方法增强：
    用装饰者模式